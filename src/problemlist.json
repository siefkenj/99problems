{
    "1": {
        "description": "Find the last element of a list.",
        "difficulty": 1,
        "function-name": "last",
	"category": "Lists",
	"abstract-example": "\\( (x_0,x_2,\\ldots,x_n)\\mapsto x_n \\)",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..10]", "output": "10"},
				{"input": "FN \"abc\"", "output": "'c'"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = 4"},
				{"input": "FN([a,b,c],X).", "output": "X = c"}
			]
		}
	}
    },
    "2": {
        "description": "Find the next-to-the-last element of a list.",
        "difficulty": 1,
        "function-name": "penultimate",
	"category": "Lists",
	"abstract-example": "\\( (x_0,x_2,\\ldots,x_{n-1},x_n)\\mapsto x_{n-1} \\)",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..10]", "output": "9"},
				{"input": "FN \"abc\"", "output": "'b'"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = 3"},
				{"input": "FN([a,b,c],X).", "output": "X = b"}
			]
		}
	}
    },
    "3": {
        "description": "Find the \\(k\\)th element of a list. The first element in the list is number 0.\n",
        "difficulty": 1,
        "function-name": "element at index",
	"abstract-example": "\\( k, (x_0,x_1,\\ldots,x_n)\\mapsto x_{k} \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 2 [0..10]", "output": "2"},
				{"input": "FN 1 \"abc\"", "output": "'b'"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(2,[0,1,2,3,4],X).", "output": "X = 2"},
				{"input": "FN(1,[a,b,c],X).", "output": "X = b"}
			]
		}
	}
    },
    "4": {
        "description": "Find the number of elements of a list.\n",
        "difficulty": 1,
        "function-name": "length",
        "example": "",
	"abstract-example": "\\( (x_1,\\ldots,x_n)\\mapsto n \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..10]", "output": "10"},
				{"input": "FN \"abc\"", "output": "3"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = 4"},
				{"input": "FN([a,b,c],X).", "output": "X = 3"}
			]
		}
	}
    },
    "5": {
        "description": "Reverse a list.\n",
        "difficulty": 1,
        "function-name": "reverse",
	"abstract-example": "\\( (x_0,x_1,\\ldots,x_{n-1},x_n)\\mapsto  (x_n,x_{n-1},\\ldots,x_{1},x_0)\\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..10]", "output": "[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]"},
				{"input": "FN \"abc\"", "output": "\"cba\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = [4,3,2,1]"},
				{"input": "FN([a,b,c],X).", "output": "X = [c,b,a]"}
			]
		}
	}
    },
    "6": {
        "description": "Find out whether a list is a palindrome. A palindrome can be read forward or backward. For example \"xamax\".",
        "difficulty": 1,
        "function-name": "palindromic",
	"abstract-example": "\\( (x_0,x_1,\\ldots,x_{n-1},x_n)\\mapsto \\mathbf{True} \\) if \\(x_i=x_{n-i}\\) and \\(\\mathbf{False}\\) otherwise.",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN \"abc\"", "output": "False"},
				{"input": "FN \"abcba\"", "output": "True"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4]).", "output": "no"},
				{"input": "FN([a,b,c,b,a]).", "output": "yes"}
			]
		}
	}
    },
    "7": {
        "description": "Flatten a nested list structure.\n",
        "difficulty": 2,
        "function-name": "flatten",
	"abstract-example": "\\( \\big(x_0,(x_1,x_2),((x_3,\\ldots\\big)\\mapsto (x_0,x_1,x_2,x_3,\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"notes": [
				"Haskell's type system requires lists to be homogeneous (they must have the exact same type). So you cannot define arbitrarily nested lists. For this problem, you will need to define a data type that simulates nested lists. Use: <code class='code'>data NestedList a = Elem a | List [NestedList a]</code>"
			],
			"examples": [
				{"input": "FN (Elem 1)", "output": "[1]"},
				{"input": "FN (List [Elem 1, List [List [], Elem 2, List [Elem 3]], Elem 4])", "output": "[1,2,3,4]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(1,X).", "output": "X = [1]"},
				{"input": "FN([1,[[],2,[3]],4],X).", "output": "X = [1,2,3,4]"}
			]
		}
	}
    },
    "8": {
        "description": "Eliminate consecutive duplicates of list elements.\n",
        "difficulty": 2,
        "function-name": "deduplicate",
	"abstract-example": "\\( (a,a,a,b,a,a,c,c,c,\\ldots)\\mapsto (a,b,a,c,\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN \"aaaabccaadeeee\"", "output": "\"abcade\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,4],X).", "output": "X = [1,2,3,4]"},
				{"input": "FN([a,a,a,b,a,a,c,c,c,c,b],X).", "output": "X = [a,b,a,c,b]"}
			]
		}
	}
    },
    "9": {
        "description": "Pack consecutive duplicates of list elements into sublists.\nIf a list contains repeated elements they should be placed in separate sublists.\n",
        "difficulty": 2,
        "function-name": "pack duplicates",
	"abstract-example": "\\( (a,a,a,b,a,a,c,c,c,\\ldots)\\mapsto \\big((a,a,a),(b),(a,a),(c,c,c),\\ldots\\big) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN \"aaaabccaadeeee\"", "output": "[\"aaaa\",\"b\",\"cc\",\"aa\",\"d\",\"eeee\"]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([a,a,a,a,b,c,c,a,a,d,e,e,e,e],X).", "output": "X = [[a,a,a],[b],[c,c],[a,a],[d],[e,e,e,e]]"}
			]
		}
	}
    },
    "10": {
        "description": "Runlength encoding of a list.\nUse the result of earlier problems to implement the so-called run-length encoding data compression method. Consecutive duplicates of elements are encoded as lists \\((e,n)\\) where \\(e\\) is the value of the element and \\(n\\) is the number of duplicates.\n",
        "difficulty": 1,
        "function-name": "runlength encode",
	"abstract-example": "\\( (a,a,a,b,a,a,c,c,c,\\ldots)\\mapsto \\big((a,3),(b,1),(a,2),(c,3),\\ldots\\big) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN \"aaaabccaadeeee\"", "output": "[('a',3),('b',1),('c',2),('a',2),('d',1),('e',4)]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([a,a,a,a,b,c,c,a,a,d,e,e,e,e],X).", "output": "X = [[a,3],[b,1],[c,2],[a,2],[d,1],[e,4]]"}
			]
		}
	}
    },
    "11": {
        "description": "Modified run-length encoding.\nModify the result of problem 10 in such a way that if an element has no duplicates it is simply copied into the result list. Only elements with duplicates are transferred as \\((e,n)\\) lists.",
        "difficulty": 1,
        "function-name": "runlength encode b",
	"abstract-example": "\\( (a,a,a,b,a,a,c,c,c,\\ldots)\\mapsto \\big((a,3),b,(a,2),(c,3),\\ldots\\big) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"notes": [
				"Haskell's type system requires lists to be homogeneous (they must have the exact same type), so you must create a new datatype which may be accomplished with: <code class='code'>data RunLen a = Single a | Multiple Int a    deriving Show</code>"
			],
			"examples": [
				{"input": "FN \"aaaabccaadeeee\"", "output": "[(Multiple 'a' 3),(Single 'b'),(Multiple 'c' 2),(Multiple 'a' 2),(Single 'd'),(Multiple 'e' 4)]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([a,a,a,a,b,c,c,a,a,d,e,e,e,e],X).", "output": "X = [[a,3],b,[c,2],[a,2],d,[e,4]]"}
			]
		}
	}
    },
    "12": {
        "description": "Decode a run-length encoded list.\nThis should undo the encoding from problem 11.",
        "difficulty": 2,
        "function-name": "runlength decode",
	"abstract-example": "\\( \\big((a,3),b,(a,2),(c,3),\\ldots\\big) \\mapsto (a,a,a,b,a,a,c,c,c,\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [(Multiple 'a' 3),(Single 'b'),(Multiple 'c' 2),(Multiple 'a' 2),(Single 'd'),(Multiple 'e' 4)]", "output": "\"aaaabccaadeeee\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([[a,3],b,[c,2],[a,2],d,[e,4]],X).", "output": "X = [a,a,a,a,b,c,c,a,a,d,e,e,e,e]"}
			]
		}
	}
    },
    "13": {
        "description": "(**) Run-length encoding of a list (direct solution). \n",
        "difficulty": 2,
        "function-name": "",
        "example": "",
	"category": "Lists",
        "language-overrides": {}
    },
    "14": {
        "description": "Double each element of a list.\n",
        "difficulty": 1,
        "function-name": "double",
	"abstract-example": "\\( (x_0,x_1,x_2,x_3,\\ldots)\\mapsto (x_0,x_0,x_1,x_1,x_2,x_2,x_2,x_3,x_3,\\ldots) \\)",
        "example": "",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [1..4]", "output": "[1,1,2,2,3,3,4,4]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN([1,2,3,a,b,c],X).", "output": "X = [1,1,2,2,3,3,a,a,b,b,c,c]"}
			]
		}
	}
    },
    "15": {
        "description": "Repeat each element of a list a given number of times.\n",
        "difficulty": 2,
        "function-name": "repeat",
	"abstract-example": "\\( k,(x_0,x_1,\\ldots)\\mapsto (\\underbrace{x_0,\\ldots,x_0}_{k},\\underbrace{x_1,\\ldots,x_1}_{k},\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [1..4]", "output": "[1,1,1,2,2,2,3,3,3,4,4,4]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[1,2,3,a,b,c],X).", "output": "X = [1,1,1,2,2,2,3,3,3,a,a,a,b,b,b,c,c,c]"}
			]
		}
	}
    },
    "16": {
        "description": "Drop every \\(k\\)th element from a list.\n",
        "difficulty": 2,
        "function-name": "drop sequence",
	"abstract-example": "\\( k,(x_1,x_2,\\ldots)\\mapsto (x_1,x_2,\\ldots,x_{k-1},x_{k+1},\\ldots,x_{2k-1},x_{2k+1},\\ldots) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [1..10]", "output": "[1,2,4,5,7,8,10]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[1,2,3,4,5,6,7,8,9,10],X).", "output": "X = [1,2,4,5,7,8,10]"}
			]
		}
	}
    },
    "17": {
        "description": "When given a length, split a list into two parts with the first part being of the specified length.\n",
        "difficulty": 1,
        "function-name": "split",
	"abstract-example": "\\( k,(x_1,x_2,\\ldots,x_n)\\mapsto (x_1,x_2,\\ldots,x_{k}),(x_{k+1},\\ldots,x_{n}) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [1..10]", "output": "([1,2,3],[4,5,6,7,8,9,10])"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[1,2,3,4,5,6,7,8,9,10],X,Y).", "output": "X = [1,2,3], Y = [4,5,6,7,8,9,10]"}
			]
		}
	}
    },
    "18": {
        "description": "Extract a slice from a list. Given numbers \\(i\\) and \\(j\\), return a sublist consisting of elements whose indices are between \\(i\\) and \\(j\\).",
        "difficulty": 2,
        "function-name": "slice",
        "abstract-example": "\\( i, j, (x_0, x_1,x_2,\\ldots,x_n)\\mapsto (x_i,x_{i+1},\\ldots,x_{j}) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 7 [0..10]", "output": "[3,4,5,6,7]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,7,[0,1,2,3,4,5,6,7,8,9,10],X).", "output": "X = [3,4,5,6,7]"}
			]
		}
	}
    },
    "19": {
        "description": "Rotate a list \\(k\\) places to the left.\n",
        "difficulty": 2,
        "function-name": "roll",
        "abstract-example": "\\( k, (x_0,x_1,\\ldots,x_n)\\mapsto (x_k,x_{k+1},\\ldots,x_{n}, x_0,x_1,\\ldots,x_{k-1}) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [1..10]", "output": "[4,5,6,7,8,9,10,1,2,3]"},
				{"input": "FN (-2) \"abcdef\"", "output": "\"efabcd\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[1,2,3,4,5,6,7,8,9,10],X).", "output": "X = [4,5,6,7,8,9,10,1,2,3]"},
				{"input": "FN(-2,[a,b,c,d,e,f],X).", "output": "X = [e,f,a,b,c,d]"}
			]
		}
	}
    },
    "20": {
        "description": "Remove the \\(k\\)th element from a list and return that element and the list with that element removed.\n",
        "difficulty": 1,
        "function-name": "pluck",
        "abstract-example": "\\( k, (x_0,x_1,\\ldots,x_n)\\mapsto x_k, (x_0,\\ldots,x_{k-1},x_{k+1},\\ldots,x_n) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 [0..10]", "output": "(3,[0,1,2,4,5,6,7,8,9,10])"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,[0,1,2,3,4,5,6,7,8,9,10],X,Y).", "output": "X = 3, Y = [0,1,2,4,5,6,7,8,9,10]"}
			]
		}
	}
    },
    "21": {
        "description": "Insert an element at a given position into a list.\n",
        "difficulty": 1,
        "function-name": "insert",
        "abstract-example": "\\( k,e, (x_0,x_1,\\ldots,x_n)\\mapsto x_k, (x_0,\\ldots,x_{k-1},e,x_{k},x_{k+1},\\ldots,x_n) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 15 [0..10]", "output": "[0,1,2,15,3,4,5,6,7,8,9,10]"},
				{"input": "FN 4 'x' \"abcdef\"", "output": "\"abcdxef\""}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,15,[0,1,2,3,4,5,6,7,8,9,10],X).", "output": "X = [0,1,2,15,3,4,5,6,7,8,9,10]"},
				{"input": "FN(4,x,[a,b,c,d,e,f],X).", "output": "[a,b,c,d,x,e,f]"}
			]
		}
	}
    },
    "22": {
        "description": "Create a list containing all integers within a given range.\n",
        "difficulty": 1,
        "function-name": "range",
        "abstract-example": "\\( i, j\\mapsto (i, i+1, \\ldots, j-1, j) \\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 8", "output": "[3,4,5,6,7,8]"}
			]
		},
		"prolog": {
			"examples": [
				{"input": "FN(3,8,X).", "output": "X = [3,4,5,6,7,8]"}
			]
		}
	}
    },
    "23": {
        "description": "Extract a given number of randomly selected elements from a list. \n",
        "difficulty": 2,
        "function-name": "take random",
        "abstract-example": "\\( i, (x_1,\\ldots,x_n)\\mapsto (x_{a_1}, x_{a_2}, \\ldots, x_{a_i}) \\) where \\((a_k)_{k=1,\\ldots, i}\\) is a random sequence with no repetitions.",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"notes": [
				"Haskell is a purely functional language, so in order to get non-deterministic results, you must use <emph>monads</emph>.  Read about monads in Haskell to get your bearings. To make Haskell's random-number monads available, add <code class='code'>import System.Random</code> to the top of your problems file.  To get a single random number between \\(i\\) and \\(j\\) wrapped in a monad, you can use the code <code class='code'>newStdGen &gt;&gt;= (\\g -&gt; return (head (randomRs (i, j) g)))</code>"
			],
			"examples": [
				{"input": "FN \"abcdefg\"", "output": "'c'"},
				{"input": "FN \"abcdefg\"", "output": "'g'"}
			]
		}
	}
    },
    "24": {
        "description": "Lotto: Draw \\(k\\) different random numbers from the set \\(1,2,\\ldots, n\\).\n",
        "difficulty": 1,
        "function-name": "lotto",
	"abstract-example": "\\( i,n \\mapsto ({a_1}, {a_2}, \\ldots, {a_i}) \\) where \\((a_k)_{k=1,\\ldots, i}\\) is a random sequence of integers with no repetitions satisfying \\(1\\leq a_k\\leq n\\).",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"notes": [
				"Haskell is a purely functional language, so in order to get non-deterministic results, you must use <emph>monads</emph>.  Read about monads in Haskell to get your bearings. To make Haskell's random-number monads available, add <code class='code'>import System.Random</code> to the top of your problems file.  To get a single random number between \\(i\\) and \\(j\\) wrapped in a monad, you can use the code <code class='code'>newStdGen &gt;&gt;= (\\g -&gt; return (head (randomRs (i, j) g)))</code>"
			],
			"examples": [
				{"input": "FN 5 10", "output": "[6,9,7,4,2]"},
				{"input": "FN 5 10", "output": "[1,2,7,3,8]"}
			]
		}
	}
    },
    "25": {
        "description": "Generate a random permutation of the elements of a list.\n",
        "difficulty": 1,
        "function-name": "permute",
        "abstract-example": "\\( (x_1,\\ldots,x_n)\\mapsto (x_{a_1}, x_{a_2}, \\ldots, x_{a_n}) \\) where \\((a_k)_{k=1,\\ldots, n}\\) is a random permutation of \\(1,2,\\ldots,n\\).",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"notes": [
				"Haskell is a purely functional language, so in order to get non-deterministic results, you must use <emph>monads</emph>.  Read about monads in Haskell to get your bearings. To make Haskell's random-number monads available, add <code class='code'>import System.Random</code> to the top of your problems file.  To get a single random number between \\(i\\) and \\(j\\) wrapped in a monad, you can use the code <code class='code'>newStdGen &gt;&gt;= (\\g -&gt; return (head (randomRs (i, j) g)))</code>"
			],
			"examples": [
				{"input": "FN [1..10]", "output": "[9,5,6,7,1,8,4,3,10,2]"},
				{"input": "FN [1..10]", "output": "[4,7,10,5,2,9,3,8,1,6]"}
			]
		}
	}
    },
    "26": {
        "description": "Generate all combinations of \\(k\\) elements from a list.  For example, you might want to find all possible committees of size 3 from a list of names of size 12.  There would be 220 such possibilities since the order of the comittee doesn't matter for combinations.  You can read more about combinations at <a href='https://en.wikipedia.org/wiki/Combination'>Wikipedia: Combinations</a>.",
        "difficulty": 2,
        "abstract-example": "\\( k, (x_1,\\ldots,x_n)\\mapsto \\big((x_1,\\ldots,x_k), (x_1,x_3,\\ldots,x_{k+1}),(x_1,x_2,x_4,\\ldots,x_{k+1}),\\ldots  \\big)\\)",
        "function-name": "combinations",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3 ['a'..'e']", "output": "[\"abc\",\"abd\",\"abe\",\"acd\",\"ace\",\"ade\",\"bcd\",\"bce\",\"bde\",\"cde\"]"}
			]
		}
	}
    },
    "27a": {
        "description": "List every way that a set of size 9 can be split into disjoint groups of sizes 2,3, and 4.",
        "difficulty": 2,
        "function-name": "group234",
        "abstract-example": "\\( (x_1,\\ldots,x_9)\\mapsto \\big([(x_1,x_2),(x_3,x_4,x_5),(x_6,\\ldots,x_9)], [(x_1,x_3),(x_2,x_4,x_5),(x_6,\\ldots,x_9)], \\ldots \\big)\\)",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [\"aldo\",\"beat\",\"carla\",\"david\",\"evi\",\"flip\",\"gary\",\"hugo\",\"ida\"]", "output": "[[[\"aldo\",\"beat\"],[\"carla\",\"david\",\"evi\"],[\"flip\",\"gary\",\"hugo\",\"ida\"]],...]\n(altogether 1260 solutions)"}
			]
		}
	}
    },
    "27b": {
        "description": "Given a list of sizes \\((a,b,c,\\ldots)\\), list every way that a set of size \\(k\\) can be split into disjoint groups of sizes \\(a,b,c,\\ldots\\).",
        "difficulty": 2,
        "function-name": "group",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [2,2,5] [\"aldo\",\"beat\",\"carla\",\"david\",\"evi\",\"flip\",\"gary\",\"hugo\",\"ida\"]", "output": "[[[\"aldo\",\"beat\"],[\"carla\",\"david\"],[\"evi\",\"flip\",\"gary\",\"hugo\",\"ida\"]],...]\n(altogether 756 solutions)"}
			]
		}
	}
    },
    "28a": {
        "description": "Sort a list of lists according to length of sublists.\n",
        "difficulty": 2,
        "function-name": "sort by length",
        "abstract-example": "\\( (L_1,\\ldots,L_n)\\mapsto (L_{a_1},\\ldots,L_{a_n})\\) satisfying \\(|L_{a_i}|\\leq |L_{a_j}|\\) whenever \\(i\\leq j\\).",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [\"abc\",\"de\",\"fgh\",\"de\",\"ijkl\",\"mn\",\"o\"]", "output": "[\"o\",\"de\",\"de\",\"mn\",\"abc\",\"fgh\",\"ijkl\"]"}
			]
		}
	}
    },
    "28b": {
        "description": "Sort a list of lists according the frequency with which the length of the list appears.\n",
        "difficulty": 2,
        "function-name": "sort by length frequency",
        "abstract-example": "\\( (L_1,\\ldots,L_n)\\mapsto (L_{a_1},\\ldots,L_{a_n})\\) satisfying \\(\\#\\{k:|L_{k}|=|L_{a_i}|\\}\\leq \\#\\{k:|L_{k}|=|L_{a_j}|\\}\\) whenever \\(i\\leq j\\).",
	"category": "Lists",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [\"abc\", \"de\", \"fgh\", \"de\", \"ijkl\", \"mn\", \"o\"]", "output": "[\"ijkl\",\"o\",\"abc\",\"fgh\",\"de\",\"de\",\"mn\"]"}
			]
		}
	}
    },
    "31": {
        "description": "Determine whether a given positive integer number is prime.\n",
        "difficulty": 2,
        "function-name": "prime",
        "abstract-example": "\\( n\\mapsto \\mathbf{True}\\) if \\(n\\) is prime and \\(\\mathbf{False}\\) otherwise.",
	"category": "Arithmetic",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 7", "output": "True"},
				{"input": "FN 6", "output": "False"}
			]
		}
	}
    },
    "32": {
        "description": "Determine the greatest common divisor of two integers. Use <a href='http://en.wikipedia.org/wiki/Euclidean_algorithm'>Euclid's algorithm</a>.\n",
        "difficulty": 2,
        "function-name": "gcd",
        "abstract-example": "\\( a,b\\mapsto k\\) satisfying \\(k\\geq 0\\) and for any \\(d\\) so that \\(d| a\\) and \\(d| b\\) then \\(d| k\\).",
	"category": "Arithmetic",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 36 63", "output": "9"},
				{"input": "FN (-3) (-6)", "output": "3"},
				{"input": "FN (-3) 6", "output": "3"}
			]
		}
	}
    },
    "33": {
        "description": "Determine whether two positive integer numbers are coprime. Two numbers are coprime if their greatest common divisor equals 1.\n",
        "difficulty": 1,
        "function-name": "coprime",
        "abstract-example": "\\( a,b\\mapsto \\mathbf{True}\\) if \\(\\mathrm{gcd}(a,b)=1\\) and \\(\\mathbf{False}\\) otherwise.",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 36 63", "output": "False"},
				{"input": "FN 35 64", "output": "True"}
			]
		}
	}
    },
    "34": {
        "description": "Calculate Euler's totient function \\(\\phi(n)\\).  That is, the number of integers in the range \\(1,2,\\ldots,n\\) that are relatively prime to \\(n\\).",
        "difficulty": 2,
        "function-name": "totient",
        "abstract-example": "\\( \\displaystyle n\\mapsto \\sum_{\\substack{1\\leq i\\leq n\\\\\\mathrm{gcd}(i,n)=1}} 1\\)",
	"category": "Arithmetic",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 10", "output": "4"},
				{"input": "FN 33", "output": "20"}
			]
		}
	}
    },
    "35": {
        "description": "List the prime factors of a given positive integer in ascending order, repeating factors if they occur multiple times.",
        "difficulty": 2,
        "function-name": "factor",
        "abstract-example": "\\( n\\mapsto (p_1,p_2,\\ldots,p_k)\\) satisfying that \\(p_i\\) is prime for all \\(i\\), \\(p_i\\leq p_j\\) if \\(i\\leq j\\), and \\(\\displaystyle n=p_1p_2\\cdots p_k\\).",
	"category": "Arithmetic",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 315", "output": "[3, 3, 5, 7]"}
			]
		}
	}
    },
    "36": {
        "description": "List the prime factors of a given number and their multiplicity.",
        "difficulty": 2,
        "function-name": "factors",
        "abstract-example": "\\( n\\mapsto \\big((p_1,a_1),(p_2,a_2),\\ldots,(p_k,a_k)\\big)\\) satisfying that \\(p_i\\) is prime for all \\(i\\), \\(p_i\\leq p_j\\) if \\(i\\leq j\\), and \\(n=p_1^{a_1}p_2^{a_2}\\cdots p_k^{a_k}\\).",
	"category": "Arithmetic",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 315", "output": "[(3,2),(5,1),(7,1)]"}
			]
		}
	}
    },
    "37": {
        "description": "Calculate Euler's totient function \\(\\phi(n)\\) using the efficient formula \\[\\phi(n)=(p_1-1)p_1^{a_1-1}(p_2-1)p_2^{a_2-1}\\cdots(p_k-1)p_k^{a_k-1}\\] where \\(n=p_1^{a_1}p_2^{a_2}\\cdots p_k^{a_k}\\) is the prime factorization of \\(n\\).",
        "difficulty": 2,
        "function-name": "efficient totient",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "38": {
        "description": "(*) Compare the two methods of calculating Euler's totient function.\n",
        "difficulty": null,
        "function-name": "",
	"category": "Arithmetic",
        "language-overrides": {}
    },
    "39": {
        "description": "List all prime numbers in a given range.",
        "difficulty": 1,
        "function-name": "primes",
        "abstract-example": "\\( i,j\\mapsto (p_1,p_2,\\ldots, p_k)\\) where \\(i\\leq p_n\\leq j\\) exhaustively list the primes between \\(i\\) and \\(j\\).",
	"category": "Arithmetic",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 10 20", "output": "[11,13,17,19]"}
			]
		}
	}
    },
    "40": {
        "description": "Goldbach's conjecture states that any <i>even</i> integer greater than 2 can be written as the sum of two primes.  For example, \\(28=5+23\\).  This conjecture has not been proved, but has been verified up to very large numbers.  Given a number, write it as the sum of two primes.",
        "difficulty": 2,
        "function-name": "goldbach",
        "abstract-example": "\\( 2n\\mapsto p_1,p_2\\) where \\(p_1,p_2\\) are prime and \\(2n=p_1+p_2\\).",
	"category": "Arithmetic",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 28", "output": "(5,23)"}
			]
		}
	}
    },
    "41": {
        "description": "Given a range of integers by its lower and upper limit, print a list of all even numbers and their Goldbach composition.\n",
        "difficulty": 2,
        "function-name": "goldbach range",
	"category": "Arithmetic",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 9 20", "output": "[(3,7),(5,7),(3,11),(3,13),(5,13),(3,17)]"}
			]
		}
	}
    },
    "46": {
        "description": "Define binary functions for and, or, nand, nor, xor, implies, and equivalent (for logical equivalence) which succeed or fail according to the result of their respective operations; e.g. and(A,B) will succeed, if and only if both A and B succeed.\n  Given a composition of binary operators that it itself a binary operator, make a truth table for it.",
        "difficulty": 2,
        "function-name": "binary truth table",
	"category": "Logic and Codes",
        "language-overrides": {}
    },
    "47": {
        "description": "Modify the functions from 46 so they may be used as infix operators.\n",
        "difficulty": 1,
        "function-name": "",
	"category": "Logic and Codes",
        "language-overrides": {}
    },
    "48": {
        "description": "Given \\(n\\) variables and an \\(n\\)-ary boolean operator, construct a truth table.\n",
        "difficulty": 2,
        "function-name": "truth table",
	"category": "Logic and Codes",
        "language-overrides": {}
    },
    "49": {
        "description": "Gray codes.  A Gray code of length \\(n\\) is a list of all \\(n\\) bit sequences satisfying the property that adjacent elements in the list differ by exactly one bit.  Read about Gray codes <a href='https://en.wikipedia.org/wiki/Gray_code'>on Wikipedia</a> and then enumerate Gray codes of length \\(n\\)",
        "difficulty": 2,
        "function-name": "gray",
	"category": "Logic and Codes",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3", "output": "[\"000\",\"001\",\"011\",\"010\",\"110\",\"111\",\"101\",\"100\"]"}
			]
		}
	}
    },
    "50": {
        "description": "Huffman codes.  Given a list of items and their frequency, a Huffman dictionary (or Huffman code) is a way to assign items to bit-strings in a maximally-efficient way.  A consequence is that if an item appears more frequently, its bit-string representation is shorter.  You can read about Huffman encoding <a href='https://en.wikipedia.org/wiki/Huffman_coding'>on Wikipedi</a> or watch a video <a href='https://www.youtube.com/watch?v=ZdooBTdW5bM'>on YouTube</a> about how to build a Huffman dictionary.",
        "difficulty": 3,
        "abstract-example": "\\( (e_1,f_1), (e_2,f_2),\\ldots \\mapsto (e_1,c_1), (e_2,c_2),\\ldots\\) where \\(e_i\\) are items, \\(f_i\\) is the frequency of \\(e_i\\) and \\(c_i\\) is the Huffman code corresponding to \\(e_i\\).",
        "function-name": "huffman dictionary",
	"category": "Logic and Codes",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [('a',45),('b',13),('c',12),('d',16),('e',9),('f',5)]", "output": "[('a',\"0\"),('b',\"101\"),('c',\"100\"),('d',\"111\"),('e',\"1101\"),('f',\"1100\")]"}
			]
		}
	}
    },
    "54A": {
        "description": "(*) Check whether a given term represents a binary tree\n",
        "difficulty": 1,
        "function-name": "",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "55": {
        "description": "Enumerate balanced binary trees.  In a completely balanced binary tree, the following property holds for every node: The number of nodes in its left subtree and the number of nodes in its right subtree are almost equal, which means their difference is not greater than one.",
        "difficulty": 2,
        "function-name": "balanced trees",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"notes": [
				"In Haskell you can create a tree data-structure with <code class='code'>data Tree a = Empty | Branch a (Tree a) (Tree a)    deriving Show</code>"
			],
			"examples": [
				{"input": "FN 1", "output": "[Branch 0 Empty Empty]"},
				{"input": "FN 2", "output": "[Branch 0 (Branch 0 Empty Empty) Empty,Branch 0 Empty (Branch 0 Empty Empty)]"},
				{"input": "FN 4", "output": "[Branch 0 (Branch 0 (Branch 0 Empty Empty) Empty) (Branch 0 Empty Empty),Branch 0 (Branch 0 Empty (Branch 0 Empty Empty)) (Branch 0 Empty Empty),Branch 0 (Branch 0 Empty Empty) (Branch 0 (Branch 0 Empty Empty) Empty),Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty (Branch 0 Empty Empty))]"}
			]
		}
	}
    },
    "56": {
        "description": "Determine whether a given binary tree is symmetric.  A binary tree is symmetric if, cutting at the root the left side's branches are a reflection of the right side's.  That is, we only care about the structure of the tree and not the contents of the nodes.",
        "difficulty": 2,
        "function-name": "symmetric tree",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN (Branch 'x' (Branch 'x' Empty Empty) Empty)", "output": "False"},
				{"input": "FN (Branch 'x' (Branch 'x' Empty Empty) (Branch 'x' Empty Empty))", "output": "True"},
				{"input": "FN (Branch 'x' (Branch 'y' Empty Empty) (Branch 'z' Empty Empty))", "output": "True"}
			]
		}
	}
    },
    "57": {
        "description": "Construct a binary search tree (dictionary) of minimum depth from a list of numbers.  Information about binary search trees can be found <a href='https://en.wikipedia.org/wiki/Binary_search_tree'>on Wikipedia</a>.\n",
        "difficulty": 2,
        "function-name": "construct search tree",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN [3, 2, 5, 7, 1]", "output": "Branch 3 (Branch 2 (Branch 1 Empty Empty) Empty) (Branch 5 Empty (Branch 7 Empty Empty))"},
				{"input": "symmetric_tree_ . FN $ [3, 2, 5, 7, 4]", "output": "False"},
				{"input": "symmetric_tree_ . FN $ [5, 3, 18, 1, 4, 12, 21]", "output": "True"}
			]
		}
	}
    },
    "58": {
        "description": "Construct all completely balanced, symmetric binary trees of a given size.",
        "difficulty": 2,
        "function-name": "balanced symmetric trees",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 5", "output": "[Branch 0 (Branch 0 (Branch 0 Empty Empty) Empty) (Branch 0 Empty (Branch 0 Empty Empty)),\nBranch 0 (Branch 0 Empty (Branch 0 Empty Empty)) (Branch 0 (Branch 0 Empty Empty) Empty)]"}
			]
		}
	}
    },
    "59": {
        "description": "Given a height, construct all height-balanced binary trees of that height.  In a height-balanced binary tree, the following property holds for every node: The height of its left subtree and the height of its right subtree are almost equal, which means their difference is not greater than one.",
        "difficulty": 2,
        "function-name": "height balanced trees of height",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 3", "output": "[Branch 0 (Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty Empty)) (Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty Empty)),\nBranch 0 (Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty Empty)) (Branch 0 (Branch 0 Empty Empty) Empty),\nBranch 0 (Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty Empty)) (Branch 0 Empty (Branch 0 Empty Empty)),\nBranch 0 (Branch 0 (Branch 0 Empty Empty) Empty) (Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty Empty)),\nBranch 0 (Branch 0 (Branch 0 Empty Empty) Empty) (Branch 0 (Branch 0 Empty Empty) Empty),\nBranch 0 (Branch 0 (Branch 0 Empty Empty) Empty) (Branch 0 Empty (Branch 0 Empty Empty)),\nBranch 0 (Branch 0 Empty (Branch 0 Empty Empty)) (Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty Empty)),\nBranch 0 (Branch 0 Empty (Branch 0 Empty Empty)) (Branch 0 (Branch 0 Empty Empty) Empty),\nBranch 0 (Branch 0 Empty (Branch 0 Empty Empty)) (Branch 0 Empty (Branch 0 Empty Empty)),\nBranch 0 (Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty Empty)) (Branch 0 Empty Empty),\nBranch 0 (Branch 0 (Branch 0 Empty Empty) Empty) (Branch 0 Empty Empty),\nBranch 0 (Branch 0 Empty (Branch 0 Empty Empty)) (Branch 0 Empty Empty),\nBranch 0 (Branch 0 Empty Empty) (Branch 0 (Branch 0 Empty Empty) (Branch 0 Empty Empty)),\nBranch 0 (Branch 0 Empty Empty) (Branch 0 (Branch 0 Empty Empty) Empty),\nBranch 0 (Branch 0 Empty Empty) (Branch 0 Empty (Branch 0 Empty Empty))]"}
			]
		}
	}
    },
    "60": {
        "description": "Given a number of nodes, construct all height-balanced binary trees with that number of nodes.  It might help to first find the maximum and minimum number of nodes that a height-balanced tree of a certain height can have.",
        "difficulty": 2,
        "function-name": "height balanced trees",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "length $ FN 15", "output": "1553"}
			]
		}
	}
    },
    "61a": {
        "description": "Count the leaves of a binary tree. A leaf is a node with no successor.",
        "difficulty": 1,
        "function-name": "count leaves",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN $ Branch 1 (Branch 2 Empty (Branch 4 Empty Empty)) (Branch 2 Empty Empty)", "output": "2"}
			]
		}
	}
    },
    "61b": {
        "description": "Find the leaves of a binary tree.",
        "difficulty": 1,
        "function-name": "leaves",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN $ Branch 1 (Branch 2 Empty (Branch 4 Empty Empty)) (Branch 2 Empty Empty)", "output": "[4,2]"}
			]
		}
	}
    },
    "62a": {
        "description": "Find the internal nodes of a binary tree.  That is, all of the non-leaf nodes.",
        "difficulty": 1,
        "function-name": "nodes",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN $ Branch 1 (Branch 2 Empty (Branch 4 Empty Empty)) (Branch 2 Empty Empty)", "output": "[1,2]"}
			]
		}
	}
    },
    "62b": {
        "description": "Find the nodes at a given height in a tree.",
        "difficulty": 1,
        "function-name": "nodes at height",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 1 $ Branch 1 (Branch 2 Empty (Branch 4 Empty Empty)) (Branch 2 Empty Empty)", "output": "[2,2]"}
			]
		}
	}
    },
    "63": {
        "description": "Construct a complete binary tree with a given number of nodes.  A complete binary tree of height \\(h\\) is one where every level up to \\(h-1\\) is full and all nodes at level \\(h\\) are as left as possible.",
        "difficulty": 2,
        "function-name": "complete tree",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN 4", "output": "Branch 0 (Branch 0 (Branch 0 Empty Empty) Empty) (Branch 0 Empty Empty)"}
			]
		}
	}
    },
    "64": {
        "description": "Layout a tree. As a preparation for drawing the tree, a layout algorithm is required to determine the position of each node in a rectangular grid. Several layout methods are conceivable, one of them is shown in the illustration below:<br/><img src='images/64tree.svg'>",
        "difficulty": 2,
        "function-name": "layout tree",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN $ Branch 'n' (Branch 'k' (Branch 'c' (Branch 'a' Empty Empty) (Branch 'h' (Branch 'g' (Branch 'e' Empty Empty) Empty) Empty)) (Branch 'm' Empty Empty)) (Branch 'u' (Branch 'p' Empty (Branch 's' (Branch 'q' Empty Empty) Empty)) Empty)", "output": "Branch ('n',(7,0)) (Branch ('k',(5,1)) (Branch ('c',(1,2)) (Branch ('a',(0,3)) Empty Empty) (Branch ('h',(4,3)) (Branch ('g',(1,4)) (Branch ('e',(0,5)) Empty Empty) Empty) Empty)) (Branch ('m',(6,2)) Empty Empty)) (Branch ('u',(11,1)) (Branch ('p',(0,2)) Empty (Branch ('s',(2,3)) (Branch ('q',(0,4)) Empty Empty) Empty)) Empty)"}
			]
		}
	}
    },
    "65": {
        "description": "Layout a tree in a more spaced out way.  An alternative layout method is depicted in the illustration below: <br><img src='images/65tree.svg'>",
        "difficulty": 2,
        "function-name": "layout tree spaced",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {
		"haskell": {
			"examples": [
				{"input": "FN $ Branch 'n' (Branch 'k' (Branch 'c' (Branch 'a' Empty Empty) (Branch 'e' (Branch 'd' Empty Empty) (Branch 'g' Empty Empty))) (Branch 'm' Empty Empty)) (Branch 'u' (Branch 'p' Empty (Branch 'q' Empty Empty)) Empty)", "output": "Branch ('n',(14,0)) (Branch ('k',(6,1)) (Branch ('c',(2,2)) (Branch ('a',(0,3)) Empty Empty) (Branch ('e',(4,3)) (Branch ('d',(3,4)) Empty Empty) (Branch ('g',(5,4)) Empty Empty))) (Branch ('m',(10,2)) Empty Empty)) (Branch ('u',(22,1)) (Branch ('p',(20,2)) Empty (Branch ('q',(21,3)) Empty Empty)) Empty)"}
			]
		}
	}
    },
    "66": {
        "description": "Layout a tree in a compact way.  Yet another layout strategy is shown in the illustration below: <br><img src='images/66tree.svg'>",
        "difficulty": 3,
        "function-name": "layout tree compact",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "67A": {
        "description": "A string representation of binary trees\n",
        "difficulty": 2,
        "function-name": "tree to string",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "68": {
        "description": "Preorder and inorder sequences of binary trees. We consider binary trees with nodes that are identified by single lower-case letters, as in the example of problem P67.\n",
        "difficulty": 2,
        "function-name": "",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "69": {
        "description": "Dotstring representation of binary trees.\n",
        "difficulty": 2,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "70": {
        "description": "(**) Tree construction from a node string.\n",
        "difficulty": null,
        "function-name": "",
	"category": "Binary Trees",
        "example": "",
        "language-overrides": {}
    },
    "70B": {
        "description": "(*) Check whether a given term represents a multiway tree.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "70C": {
        "description": "(*) Count the nodes of a multiway tree.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "71": {
        "description": "(*) Determine the internal path length of a tree.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "72": {
        "description": "(*) Construct the bottom-up order sequence of the tree nodes.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "73": {
        "description": "(**) Lisp-like tree representation.\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "80": {
        "description": "(***) Conversions\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "81": {
        "description": "(**) Path from one node to another one\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "82": {
        "description": "(*) Cycle from a given node\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "83": {
        "description": "(**) Construct all spanning trees \n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "84": {
        "description": "(**) Construct the minimal spanning tree\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "85": {
        "description": "(**) Graph isomorphism\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "86": {
        "description": "(**) Node degree and graph coloration\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "87": {
        "description": "(**) Depth-first order graph traversal (alternative solution)\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "88": {
        "description": "(**) Connected components (alternative solution)\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "89": {
        "description": "(**) Bipartite graphs\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "90": {
        "description": "(**) Eight queens problem\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "91": {
        "description": "(**) Knight's tour\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "92": {
        "description": "(***) Von Koch's conjecture\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "93": {
        "description": "(***) An arithmetic puzzle\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "94": {
        "description": "(***) Generate K-regular simple graphs with N nodes\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "95": {
        "description": "(**) English number words\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "96": {
        "description": "(**) Syntax checker\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "97": {
        "description": "(**) Sudoku\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "98": {
        "description": "(***) Nonograms\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    },
    "99": {
        "description": "(***) Crossword puzzle\n",
        "difficulty": null,
        "function-name": "",
        "example": "",
        "language-overrides": {}
    }
}
